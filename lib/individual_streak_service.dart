import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter/foundation.dart';
import 'milestone_notification_service.dart';

/// Informaci√≥n de racha individual para un desaf√≠o espec√≠fico
class ChallengeStreak {
  final String challengeId;
  final String challengeTitle;
  final int currentStreak;
  final int longestStreak;
  final DateTime? lastConfirmedDate;
  final List<DateTime> confirmationHistory;
  final List<DateTime> failedDays;
  final int forgivenessTokens; // Fichas de perd√≥n
  final DateTime? lastForgivenessUsed;
  final int totalPoints;
  final bool isRetroactive; // üÜï NUEVO: Flag para identificar retos retroactivos

  ChallengeStreak({
    required this.challengeId,
    required this.challengeTitle,
    this.currentStreak = 0,
    this.longestStreak = 0,
    this.lastConfirmedDate,
    this.confirmationHistory = const [],
    this.failedDays = const [],
    this.forgivenessTokens = 2, // Iniciar con 2 fichas de perd√≥n
    this.lastForgivenessUsed,
    this.totalPoints = 0,
    this.isRetroactive = false, // üÜï NUEVO: Por defecto no es retroactivo
  });

  Map<String, dynamic> toJson() => {
    'challengeId': challengeId,
    'challengeTitle': challengeTitle,
    'currentStreak': currentStreak,
    'longestStreak': longestStreak,
    'lastConfirmedDate': lastConfirmedDate?.toIso8601String(),
    'confirmationHistory': confirmationHistory.map((d) => d.toIso8601String()).toList(),
    'failedDays': failedDays.map((d) => d.toIso8601String()).toList(),
    'forgivenessTokens': forgivenessTokens,
    'lastForgivenessUsed': lastForgivenessUsed?.toIso8601String(),
    'totalPoints': totalPoints,
    'isRetroactive': isRetroactive, // üÜï NUEVO
  };

  static ChallengeStreak fromJson(Map<String, dynamic> json) => ChallengeStreak(
    challengeId: json['challengeId'] ?? '',
    challengeTitle: json['challengeTitle'] ?? '',
    currentStreak: json['currentStreak'] ?? 0,
    longestStreak: json['longestStreak'] ?? 0,
    lastConfirmedDate: json['lastConfirmedDate'] != null 
        ? DateTime.parse(json['lastConfirmedDate']) 
        : null,
    confirmationHistory: (json['confirmationHistory'] as List<dynamic>? ?? [])
        .map((d) => DateTime.parse(d.toString()))
        .toList(),
    failedDays: (json['failedDays'] as List<dynamic>? ?? [])
        .map((d) => DateTime.parse(d.toString()))
        .toList(),
    forgivenessTokens: json['forgivenessTokens'] ?? 2,
    lastForgivenessUsed: json['lastForgivenessUsed'] != null 
        ? DateTime.parse(json['lastForgivenessUsed']) 
        : null,
    totalPoints: json['totalPoints'] ?? 0,
    isRetroactive: json['isRetroactive'] ?? false, // üÜï NUEVO: Retrocompatibilidad
  );

  ChallengeStreak copyWith({
    String? challengeId,
    String? challengeTitle,
    int? currentStreak,
    int? longestStreak,
    DateTime? lastConfirmedDate,
    List<DateTime>? confirmationHistory,
    List<DateTime>? failedDays,
    int? forgivenessTokens,
    DateTime? lastForgivenessUsed,
    int? totalPoints,
    bool? isRetroactive, // üÜï NUEVO
  }) => ChallengeStreak(
    challengeId: challengeId ?? this.challengeId,
    challengeTitle: challengeTitle ?? this.challengeTitle,
    currentStreak: currentStreak ?? this.currentStreak,
    longestStreak: longestStreak ?? this.longestStreak,
    lastConfirmedDate: lastConfirmedDate ?? this.lastConfirmedDate,
    confirmationHistory: confirmationHistory ?? this.confirmationHistory,
    failedDays: failedDays ?? this.failedDays,
    forgivenessTokens: forgivenessTokens ?? this.forgivenessTokens,
    lastForgivenessUsed: lastForgivenessUsed ?? this.lastForgivenessUsed,
    totalPoints: totalPoints ?? this.totalPoints,
    isRetroactive: isRetroactive ?? this.isRetroactive, // üÜï NUEVO
  );

  /// Verifica si el desaf√≠o ha sido completado hoy
  bool get isCompletedToday {
    if (lastConfirmedDate == null) return false;
    final today = DateTime.now();
    final lastConfirmed = lastConfirmedDate!;
    return lastConfirmed.year == today.year &&
           lastConfirmed.month == today.month &&
           lastConfirmed.day == today.day;
  }

  /// Verifica si el usuario puede usar una ficha de perd√≥n
  bool get canUseForgiveness {
    if (forgivenessTokens <= 0) return false;
    
    // Solo se puede usar una ficha por d√≠a
    if (lastForgivenessUsed != null) {
      final today = DateTime.now();
      final lastUsed = lastForgivenessUsed!;
      if (lastUsed.year == today.year &&
          lastUsed.month == today.month &&
          lastUsed.day == today.day) {
        return false;
      }
    }
    
    return true;
  }

  /// Calcula los d√≠as consecutivos sin fallar
  int get consecutiveDaysWithoutFailure {
    if (confirmationHistory.isEmpty) return 0;
    
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    int streak = 0;

    // Revisar hacia atr√°s desde hoy
    for (int i = 0; i <= currentStreak; i++) {
      final checkDate = today.subtract(Duration(days: i));
      
      // Si hay un fallo en esta fecha, romper
      final hasFailed = failedDays.any((failDate) {
        final failed = DateTime(failDate.year, failDate.month, failDate.day);
        return failed.isAtSameMomentAs(checkDate);
      });
      
      if (hasFailed) break;
      
      // Si hay confirmaci√≥n en esta fecha, contar
      final hasConfirmation = confirmationHistory.any((confirmation) {
        final confirmed = DateTime(confirmation.year, confirmation.month, confirmation.day);
        return confirmed.isAtSameMomentAs(checkDate);
      });

      if (hasConfirmation || i == 0) { // Incluir hoy aunque no est√© confirmado a√∫n
        streak++;
      } else {
        break;
      }
    }

    return streak;
  }
}

/// Servicio para manejar rachas individuales por desaf√≠o
class IndividualStreakService extends ChangeNotifier {
  static final IndividualStreakService _instance = IndividualStreakService._internal();
  factory IndividualStreakService() => _instance;
  IndividualStreakService._internal();

  static IndividualStreakService get instance => _instance;

  Map<String, ChallengeStreak> _streaks = {};
  Map<String, ChallengeStreak> get streaks => Map.unmodifiable(_streaks);

  /// Cargar rachas desde SharedPreferences
  Future<void> loadStreaks() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString('individual_streaks');
      if (jsonString != null) {
        final Map<String, dynamic> json = jsonDecode(jsonString);
        _streaks = json.map((key, value) => 
            MapEntry(key, ChallengeStreak.fromJson(value)));
      }
    } catch (e) {
      debugPrint('‚ùå Error loading individual streaks: $e');
      _streaks = {};
    }
    notifyListeners();
  }

  /// Guardar rachas en SharedPreferences
  Future<void> _saveStreaks() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final json = _streaks.map((key, value) => 
          MapEntry(key, value.toJson()));
      final jsonString = jsonEncode(json);
      await prefs.setString('individual_streaks', jsonString);
    } catch (e) {
      debugPrint('‚ùå Error saving individual streaks: $e');
    }
  }

  /// Registrar o crear un nuevo desaf√≠o
  Future<void> registerChallenge(String challengeId, String challengeTitle) async {
    debugPrint('üîç === registerChallenge ===');
    debugPrint('üîç challengeId: $challengeId');
    debugPrint('üîç challengeTitle: $challengeTitle');
    debugPrint('üîç ¬øYa existe?: ${_streaks.containsKey(challengeId)}');
    
    if (!_streaks.containsKey(challengeId)) {
      _streaks[challengeId] = ChallengeStreak(
        challengeId: challengeId,
        challengeTitle: challengeTitle,
        currentStreak: 0, // üîß CORRECCI√ìN: Siempre empezar en 0 para retos nuevos
        longestStreak: 0,
        lastConfirmedDate: null,
        confirmationHistory: const [],
        totalPoints: 0,
      );
      await _saveStreaks();
      notifyListeners();
      debugPrint('üÜï Nuevo reto registrado: $challengeTitle (racha inicial: 0)');
      debugPrint('üîç Historial inicial vac√≠o: ${_streaks[challengeId]!.confirmationHistory.length} entradas');
    } else {
      final existing = _streaks[challengeId]!;
      debugPrint('üîÑ Reto ya existente: $challengeTitle');
      debugPrint('üîç   Racha actual: ${existing.currentStreak}');
      debugPrint('üîç   Historial: ${existing.confirmationHistory.map((d) => '${d.day}/${d.month}').join(', ')}');
    }
  }

  /// üÜï NUEVO: Migrar datos de racha de ID legacy a UUID
  Future<void> migrateStreakToNewId(String legacyId, String newUuid) async {
    debugPrint('üîÑ === migrateStreakToNewId ===');
    debugPrint('üîÑ Legacy ID: $legacyId');
    debugPrint('üîÑ New UUID: $newUuid');
    
    // Obtener datos del ID legacy
    final legacyStreak = _streaks[legacyId];
    if (legacyStreak == null) {
      debugPrint('‚ö†Ô∏è No se encontraron datos para el ID legacy: $legacyId');
      return;
    }
    
    // Verificar si el UUID ya existe
    if (_streaks.containsKey(newUuid)) {
      debugPrint('‚ö†Ô∏è UUID $newUuid ya existe, conservando datos existentes');
      return;
    }
    
    // Migrar datos al nuevo UUID
    _streaks[newUuid] = legacyStreak.copyWith(
      challengeId: newUuid, // Actualizar el ID interno si existe
      challengeTitle: legacyStreak.challengeTitle, // Preservar t√≠tulo
    );
    
    // Remover entrada legacy
    _streaks.remove(legacyId);
    
    debugPrint('‚úÖ Migraci√≥n completada: $legacyId ‚Üí $newUuid');
    debugPrint('   ‚Ä¢ Racha: ${legacyStreak.currentStreak} d√≠as');
    debugPrint('   ‚Ä¢ Puntos: ${legacyStreak.totalPoints}');
    debugPrint('   ‚Ä¢ Confirmaciones: ${legacyStreak.confirmationHistory.length}');
    
    // Guardar cambios
    await _saveStreaks();
    notifyListeners();
  }

  /// Confirmar un desaf√≠o (mantener/aumentar racha)
  Future<void> confirmChallenge(String challengeId, String challengeTitle, {bool isNegativeHabit = false}) async {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    debugPrint('üîç === INICIO confirmChallenge ===');
    debugPrint('üîç Challenge ID: $challengeId');
    debugPrint('üîç Challenge Title: $challengeTitle');
    debugPrint('üîç Is Negative Habit: $isNegativeHabit');
    debugPrint('üîç Fecha de confirmaci√≥n: ${today.day}/${today.month}/${today.year}');

    // Asegurar que el desaf√≠o existe
    await registerChallenge(challengeId, challengeTitle);
    
    final current = _streaks[challengeId]!;
    
    debugPrint('üîç Estado ANTES de confirmar:');
    debugPrint('üîç   Racha actual: ${current.currentStreak}');
    debugPrint('üîç   √öltima confirmaci√≥n: ${current.lastConfirmedDate}');
    debugPrint('üîç   Historial confirmaciones: ${current.confirmationHistory.map((d) => '${d.day}/${d.month}').join(', ')}');
    debugPrint('üîç   isCompletedToday: ${current.isCompletedToday}');
    
    // No permitir confirmar dos veces el mismo d√≠a
    if (current.isCompletedToday) {
      debugPrint('‚ö†Ô∏è Desaf√≠o $challengeId ya confirmado hoy');
      return;
    }

    // üîß MEJORADO: Usar flag expl√≠cito en lugar de inferir
    int newStreak; // Declarar variable aqu√≠

    if (current.isRetroactive) {
      debugPrint('üîÑ Reto retroactivo (marcado expl√≠citamente) - manejo especial');
      
      // Para retos retroactivos, solo agregar confirmaci√≥n de HOY sin recalcular racha completa
      final newHistory = [...current.confirmationHistory, now];
      
      // Mantener la racha actual + 1 (simple incremento)
      newStreak = current.currentStreak + 1;
      
      debugPrint('üîÑ Racha retroactiva mantenida: ${current.currentStreak} + 1 = $newStreak');
      
      // üîß CORRECCI√ìN CR√çTICA: Para retos retroactivos, recalcular puntos totales
      // Los puntos deben reflejar la racha ACTUAL, no acumularse incorrectamente
      int totalPoints = 10 + (newStreak * 2);
      
      // Actualizar con rec√°lculo total de puntos
      _streaks[challengeId] = current.copyWith(
        currentStreak: newStreak,
        longestStreak: newStreak > current.longestStreak ? newStreak : current.longestStreak,
        lastConfirmedDate: now,
        confirmationHistory: newHistory,
        totalPoints: totalPoints, // üîß USAR puntos totales, no sumar
      );
    } else {
      debugPrint('üîÑ Reto normal - c√°lculo est√°ndar');
      
      // Agregar confirmaci√≥n al historial
      final newHistory = [...current.confirmationHistory, now];
      
      debugPrint('üîç Nuevo historial: ${newHistory.map((d) => '${d.day}/${d.month}').join(', ')}');
      
      // Calcular nueva racha para retos normales
      newStreak = _calculateStreak(current.copyWith(
        confirmationHistory: newHistory,
        lastConfirmedDate: now,
      ));
      
      debugPrint('üîç Nueva racha calculada: $newStreak');
      
      // üîß CORRECCI√ìN CR√çTICA: Recalcular puntos totales correctamente
      // Los puntos deben reflejar la racha ACTUAL, no acumularse incorrectamente
      int totalPoints = 10 + (newStreak * 2);
      
      debugPrint('üîç Puntos totales calculados: $totalPoints (f√≥rmula: 10 + $newStreak * 2)');
      
      // Actualizar racha
      _streaks[challengeId] = current.copyWith(
        currentStreak: newStreak,
        longestStreak: newStreak > current.longestStreak ? newStreak : current.longestStreak,
        lastConfirmedDate: now,
        confirmationHistory: newHistory,
        totalPoints: totalPoints, // üîß USAR puntos totales, no sumar
      );
    }

    await _saveStreaks();
    notifyListeners();
    
    // üÜï NUEVO: Verificar y enviar notificaciones de hitos
    await MilestoneNotificationService.checkMilestoneNotification(
      challengeId,
      challengeTitle,
      newStreak,
      isNegativeHabit: isNegativeHabit,
    );
    
    debugPrint('üîç Estado DESPU√âS de confirmar:');
    final updated = _streaks[challengeId]!;
    debugPrint('üîç   Racha actualizada: ${updated.currentStreak}');
    debugPrint('üîç   Historial final: ${updated.confirmationHistory.map((d) => '${d.day}/${d.month}').join(', ')}');
    debugPrint('‚úÖ Desaf√≠o $challengeId confirmado. Racha: $newStreak d√≠as');
    debugPrint('üîç === FIN confirmChallenge ===');
  }

  /// Otorgar racha retroactiva para retos registrados tarde (FUNCI√ìN ESPECIAL)
  /// üîß CORREGIDO: Ahora usa _calculateStreak para calcular la racha correctamente
  Future<void> grantBackdatedStreak(String challengeId, String challengeTitle, DateTime startDate, int daysToGrant) async {
    debugPrint('üîÑ === INICIANDO grantBackdatedStreak ===');
    debugPrint('üîÑ Challenge: $challengeTitle');
    debugPrint('üîÑ Start Date: $startDate');
    debugPrint('üîÑ Days to Grant: $daysToGrant');
    
    // Crear historial de confirmaciones retroactivas (EXCLUYENDO HOY)
    final backdatedHistory = <DateTime>[];
    final today = DateTime.now();
    final todayNormalized = DateTime(today.year, today.month, today.day);
    
    for (int i = 0; i < daysToGrant; i++) {
      final confirmDate = startDate.add(Duration(days: i));
      final confirmDateNormalized = DateTime(confirmDate.year, confirmDate.month, confirmDate.day);
      
      // üîß CORRECCI√ìN CR√çTICA: No incluir HOY en el historial retroactivo
      // HOY debe confirmarse manualmente en la ventana de confirmaci√≥n
      if (!confirmDateNormalized.isAtSameMomentAs(todayNormalized)) {
        backdatedHistory.add(confirmDate);
      }
    }
    
    debugPrint('üîÑ Historial retroactivo creado (SIN hoy): ${backdatedHistory.map((d) => '${d.day}/${d.month}').join(', ')}');
    debugPrint('üîÑ HOY (${today.day}/${today.month}) NO incluido - requiere confirmaci√≥n manual');
    
    // üîß CORRECCI√ìN: Crear objeto temporal para calcular racha correctamente
    final tempStreak = ChallengeStreak(
      challengeId: challengeId,
      challengeTitle: challengeTitle,
      confirmationHistory: backdatedHistory,
      lastConfirmedDate: backdatedHistory.isNotEmpty ? backdatedHistory.last : null,
    );
    
    // üîß USAR _calculateStreak para obtener la racha correcta
    final calculatedStreak = _calculateStreak(tempStreak);
    debugPrint('üîÑ Racha calculada por _calculateStreak: $calculatedStreak');
    
    // üîß CORRECCI√ìN CR√çTICA: Puntos retroactivos = puntos finales √∫nicamente
    // NO sumar progresivamente, solo calcular puntos de la racha final
    int pointsToAdd = 10 + (calculatedStreak * 2);
    debugPrint('üîÑ Puntos calculados para racha retroactiva: $pointsToAdd (f√≥rmula: 10 + ${calculatedStreak} * 2)');
    
    // Crear el reto con la racha calculada correctamente
    _streaks[challengeId] = ChallengeStreak(
      challengeId: challengeId,
      challengeTitle: challengeTitle,
      currentStreak: calculatedStreak, // üîß USAR racha calculada
      longestStreak: calculatedStreak,
      lastConfirmedDate: backdatedHistory.isNotEmpty ? backdatedHistory.last : null,
      confirmationHistory: backdatedHistory,
      totalPoints: pointsToAdd,
      isRetroactive: true, // üÜï MARCAR como retroactivo expl√≠citamente
    );

    await _saveStreaks();
    notifyListeners();
    
    debugPrint('üéâ ‚úÖ Reto retroactivo creado con racha calculada: $calculatedStreak d√≠as');
    debugPrint('ÔøΩ ¬øCompletado HOY?: ${_streaks[challengeId]?.isCompletedToday ?? false} (debe ser FALSE para mostrar bot√≥n)');
    debugPrint('ÔøΩüîÑ === FIN grantBackdatedStreak ===');
  }

  /// Fallar en un desaf√≠o (puede usar ficha de perd√≥n)
  Future<bool> failChallenge(String challengeId, String challengeTitle, {bool useForgiveness = false}) async {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    // Asegurar que el desaf√≠o existe
    await registerChallenge(challengeId, challengeTitle);
    
    final current = _streaks[challengeId]!;

    // Intentar usar ficha de perd√≥n si se solicita
    if (useForgiveness && current.canUseForgiveness) {
      // üîß MEJORADO: La ficha de perd√≥n SIMULA confirmaci√≥n del d√≠a perdido
      final yesterday = DateTime(now.year, now.month, now.day - 1);
      
      // Agregar confirmaci√≥n autom√°tica del d√≠a perdido
      final newConfirmationHistory = [...current.confirmationHistory, yesterday];
      
      // Recalcular racha con la nueva confirmaci√≥n simulada
      final tempStreak = current.copyWith(confirmationHistory: newConfirmationHistory);
      final newCurrentStreak = _calculateStreak(tempStreak);
      final newLongestStreak = newCurrentStreak > current.longestStreak 
          ? newCurrentStreak 
          : current.longestStreak;
      
      // üîß CORRECCI√ìN CR√çTICA: Recalcular puntos totales correctamente
      final totalPoints = 10 + (newCurrentStreak * 2);
      
      _streaks[challengeId] = current.copyWith(
        forgivenessTokens: current.forgivenessTokens - 1,
        lastForgivenessUsed: now,
        confirmationHistory: newConfirmationHistory,
        currentStreak: newCurrentStreak,
        longestStreak: newLongestStreak,
        totalPoints: totalPoints, // üîß USAR puntos totales, no sumar
      );
      
      await _saveStreaks();
      notifyListeners();
      
      debugPrint('üõ°Ô∏è Ficha de perd√≥n usada para $challengeId:');
      debugPrint('   üìÖ Confirmaci√≥n simulada: ${yesterday.day}/${yesterday.month}/${yesterday.year}');
      debugPrint('   üî• Racha actualizada: ${current.currentStreak} ‚Üí $newCurrentStreak');
      debugPrint('   ‚≠ê Puntos totales: $totalPoints');
      debugPrint('   üõ°Ô∏è Fichas restantes: ${current.forgivenessTokens - 1}');
      return true; // Fallo perdonado Y confirmaci√≥n simulada
    }

    // Fallo normal: resetear racha Y PUNTOS
    final newFailedDays = [...current.failedDays, today];
    
    _streaks[challengeId] = current.copyWith(
      currentStreak: 0,
      failedDays: newFailedDays,
      totalPoints: 0, // üîß RESETEAR PUNTOS cuando falla
      confirmationHistory: const [], // üîß LIMPIAR historial cuando falla
    );

    await _saveStreaks();
    notifyListeners();
    
    debugPrint('üíî Desaf√≠o $challengeId fall√≥. Racha reseteada.');
    return false; // Fallo real
  }

  /// Calcular racha actual basada en el historial
  int _calculateStreak(ChallengeStreak streak) {
    debugPrint('üßÆ === INICIO _calculateStreak ===');
    debugPrint('üßÆ Challenge: ${streak.challengeTitle}');
    debugPrint('üßÆ Historial inicial: ${streak.confirmationHistory.map((d) => '${d.day}/${d.month}').join(', ')}');
    
    if (streak.confirmationHistory.isEmpty) {
      debugPrint('üßÆ Historial vac√≠o, retornar 0');
      return 0;
    }
    
    // Obtener todas las confirmaciones √∫nicas (sin duplicados de mismo d√≠a)
    final uniqueConfirmations = <DateTime>{};
    for (final confirmation in streak.confirmationHistory) {
      final normalizedDate = DateTime(confirmation.year, confirmation.month, confirmation.day);
      uniqueConfirmations.add(normalizedDate);
    }
    
    final sortedConfirmations = uniqueConfirmations.toList();
    sortedConfirmations.sort((a, b) => b.compareTo(a)); // M√°s reciente primero
    
    debugPrint('üßÆ Confirmaciones √∫nicas ordenadas: ${sortedConfirmations.map((d) => '${d.day}/${d.month}').join(', ')}');
    
    if (sortedConfirmations.isEmpty) return 0;
    
    int currentStreak = 0;
    
    // üîß NUEVA L√ìGICA: Empezar desde la confirmaci√≥n m√°s reciente
    DateTime expectedDate = sortedConfirmations.first;
    
    debugPrint('üßÆ Empezando desde la confirmaci√≥n m√°s reciente: ${expectedDate.day}/${expectedDate.month}');
    
    // Contar d√≠as consecutivos hacia atr√°s desde la confirmaci√≥n m√°s reciente
    for (final confirmDate in sortedConfirmations) {
      debugPrint('üßÆ Verificando: ${confirmDate.day}/${confirmDate.month}');
      debugPrint('üßÆ   Esperada: ${expectedDate.day}/${expectedDate.month}');
      
      // Si hay un fallo registrado para esta fecha, parar
      final hasFailed = streak.failedDays.any((failDate) {
        final failed = DateTime(failDate.year, failDate.month, failDate.day);
        return failed.isAtSameMomentAs(confirmDate);
      });
      
      if (hasFailed) {
        debugPrint('üßÆ   ‚ùå Hay fallo registrado, parar');
        break;
      }
      
      // Si esta confirmaci√≥n es para la fecha que esperamos, continuar racha
      if (confirmDate.isAtSameMomentAs(expectedDate)) {
        currentStreak++;
        expectedDate = expectedDate.subtract(Duration(days: 1));
        debugPrint('üßÆ   ‚úÖ Racha aumenta a: $currentStreak');
        debugPrint('üßÆ   Siguiente esperada: ${expectedDate.day}/${expectedDate.month}');
      } else {
        // Hueco en la racha, parar
        debugPrint('üßÆ   ‚ùå Hueco en la racha, parar');
        break;
      }
    }

    debugPrint('üßÆ Racha final calculada: $currentStreak');
    debugPrint('üßÆ === FIN _calculateStreak ===');
    return currentStreak;
  }

  /// Obtener racha de un desaf√≠o espec√≠fico
  ChallengeStreak? getStreak(String challengeId) {
    return _streaks[challengeId];
  }

  /// Regenerar fichas de perd√≥n (llamar diariamente o semanalmente)
  Future<void> regenerateForgivenessTokens() async {
    bool hasChanges = false;
    
    for (final entry in _streaks.entries) {
      final streak = entry.value;
      
      // Regenerar 1 ficha por semana (m√°ximo 3)
      if (streak.forgivenessTokens < 3) {
        final lastUsed = streak.lastForgivenessUsed;
        if (lastUsed == null || 
            DateTime.now().difference(lastUsed).inDays >= 7) {
          
          _streaks[entry.key] = streak.copyWith(
            forgivenessTokens: (streak.forgivenessTokens + 1).clamp(0, 3),
          );
          hasChanges = true;
        }
      }
    }
    
    if (hasChanges) {
      await _saveStreaks();
      notifyListeners();
      debugPrint('üîÑ Fichas de perd√≥n regeneradas');
    }
  }

  /// Obtener estad√≠sticas globales de todos los desaf√≠os
  Map<String, dynamic> getGlobalStats() {
    if (_streaks.isEmpty) {
      return {
        'totalChallenges': 0,
        'activeChallenges': 0,
        'totalPoints': 0,
        'averageStreak': 0.0,
        'averageActiveStreak': 0.0, // üÜï NUEVO: Promedio solo de activos
        'longestOverallStreak': 0,
        'completionRate': 0.0, // üÜï NUEVO: Tasa de finalizaci√≥n
      };
    }

    final totalPoints = _streaks.values
        .map((s) => s.totalPoints)
        .fold<int>(0, (a, b) => a + b);
    
    final averageStreak = _streaks.values
        .map((s) => s.currentStreak)
        .fold<double>(0, (a, b) => a + b) / _streaks.length;
    
    // üÜï NUEVO: Promedio solo de retos activos (racha > 0)
    final activeStreaks = _streaks.values.where((s) => s.currentStreak > 0);
    final averageActiveStreak = activeStreaks.isNotEmpty 
        ? activeStreaks.map((s) => s.currentStreak).fold<double>(0, (a, b) => a + b) / activeStreaks.length
        : 0.0;
    
    final longestOverallStreak = _streaks.values
        .map((s) => s.longestStreak)
        .fold<int>(0, (a, b) => a > b ? a : b);

    // üÜï NUEVO: Tasa de finalizaci√≥n (retos activos / total)
    final activeChallenges = _streaks.values.where((s) => s.currentStreak > 0).length;
    final completionRate = activeChallenges / _streaks.length;

    return {
      'totalChallenges': _streaks.length,
      'activeChallenges': activeChallenges,
      'totalPoints': totalPoints,
      'averageStreak': averageStreak,
      'averageActiveStreak': averageActiveStreak, // üÜï NUEVO
      'longestOverallStreak': longestOverallStreak,
      'completionRate': completionRate, // üÜï NUEVO
    };
  }

  /// Eliminar racha de un desaf√≠o
  Future<void> removeChallenge(String challengeId) async {
    _streaks.remove(challengeId);
    await _saveStreaks();
    
    // üÜï NUEVO: Limpiar datos de hitos asociados
    await MilestoneNotificationService.clearMilestoneData(challengeId);
    
    notifyListeners();
  }

  /// üîß DEBUG: Resetear racha espec√≠fica para testing
  Future<void> debugResetStreak(String challengeId) async {
    if (_streaks.containsKey(challengeId)) {
      final current = _streaks[challengeId]!;
      _streaks[challengeId] = current.copyWith(
        currentStreak: 0,
        longestStreak: 0,
        lastConfirmedDate: null,
        confirmationHistory: const [],
        totalPoints: 0,
      );
      await _saveStreaks();
      notifyListeners();
      debugPrint('üîß DEBUG: Racha reseteada para $challengeId');
    }
  }

  /// üîß DEBUG: Mostrar estado completo de un reto
  void debugShowStreakState(String challengeId) {
    if (_streaks.containsKey(challengeId)) {
      final streak = _streaks[challengeId]!;
      debugPrint('üîç === ESTADO COMPLETO DE $challengeId ===');
      debugPrint('üîç T√≠tulo: ${streak.challengeTitle}');
      debugPrint('üîç Racha actual: ${streak.currentStreak}');
      debugPrint('üîç Racha m√°s larga: ${streak.longestStreak}');
      debugPrint('üîç √öltima confirmaci√≥n: ${streak.lastConfirmedDate}');
      debugPrint('üîç Historial (${streak.confirmationHistory.length} entradas):');
      for (int i = 0; i < streak.confirmationHistory.length; i++) {
        final date = streak.confirmationHistory[i];
        debugPrint('üîç   [$i] ${date.day}/${date.month}/${date.year}');
      }
      debugPrint('üîç Puntos totales: ${streak.totalPoints}');
      debugPrint('üîç ===============================');
    } else {
      debugPrint('üîç Reto $challengeId no encontrado');
    }
  }

  /// Migrar desde el sistema global de rachas
  Future<void> migrateFromGlobalStreak(Map<String, String> challengeIdToTitle, int globalStreak) async {
    debugPrint('üîÑ Iniciando migraci√≥n desde racha global: $globalStreak d√≠as');
    
    for (final entry in challengeIdToTitle.entries) {
      final challengeId = entry.key;
      final challengeTitle = entry.value;
      
      if (!_streaks.containsKey(challengeId)) {
        // üîß CORRECCI√ìN: Solo crear racha migrada si el globalStreak es significativo
        if (globalStreak > 0) {
          debugPrint('‚úÖ Migrando reto "$challengeTitle" con $globalStreak d√≠as de racha');
          
          // Crear racha inicial basada en la racha global
          _streaks[challengeId] = ChallengeStreak(
            challengeId: challengeId,
            challengeTitle: challengeTitle,
            currentStreak: globalStreak,
            longestStreak: globalStreak,
            lastConfirmedDate: globalStreak > 0 ? DateTime.now() : null,
            confirmationHistory: [], // Sin historial espec√≠fico en migraci√≥n
            totalPoints: globalStreak * 12, // Puntos estimados
          );
        } else {
          debugPrint('‚ö†Ô∏è Omitiendo migraci√≥n para "$challengeTitle" (globalStreak: $globalStreak)');
          
          // Crear reto nuevo sin racha previa
          _streaks[challengeId] = ChallengeStreak(
            challengeId: challengeId,
            challengeTitle: challengeTitle,
            currentStreak: 0,
            longestStreak: 0,
            lastConfirmedDate: null,
            confirmationHistory: const [],
            totalPoints: 0,
          );
        }
      } else {
        debugPrint('üîÑ Reto "$challengeTitle" ya existe, mantener datos actuales');
      }
    }
    
    await _saveStreaks();
    notifyListeners();
    debugPrint('üîÑ Migraci√≥n desde racha global completada');
  }

  // üö® M√âTODO DE EMERGENCIA: Reset completo de datos corruptos
  Future<void> emergencyResetCorruptedData() async {
    final prefs = await SharedPreferences.getInstance();
    
    debugPrint('üö® EMERGENCIA: Iniciando reset de datos corruptos...');
    
    // 1. Resetear todos los datos de rachas individuales
    await prefs.remove('individual_streaks');
    debugPrint('‚úÖ Rachas individuales eliminadas');
    
    // 2. Resetear flag de migraci√≥n para permitir nueva migraci√≥n limpia
    await prefs.setBool('has_migrated_individual_streaks', false);
    debugPrint('‚úÖ Flag de migraci√≥n reseteado');
    
    // 3. Verificar si hay rachas globales para preservar
    final globalStreak = prefs.getInt('global_streak') ?? 0;
    debugPrint('‚ÑπÔ∏è Racha global encontrada: $globalStreak');
    
    // 4. Limpiar cach√© local
    _streaks.clear();
    
    debugPrint('üö® EMERGENCIA: Reset completado. Necesita restart de la app.');
    notifyListeners();
  }

  // üîß M√âTODO QUIR√öRGICO: Solo resetear retos problem√°ticos espec√≠ficos
  Future<void> surgicalResetKnownBugs() async {
    debugPrint('üîß QUIR√öRGICO: Iniciando correcci√≥n de retos problem√°ticos...');
    
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final List<String> suspiciousChallenges = [];
    
    // Buscar retos con lastConfirmedDate sospechosos
    for (final entry in _streaks.entries) {
      final challengeId = entry.key;
      final streak = entry.value;
      
      if (streak.lastConfirmedDate != null) {
        final lastConfirmed = streak.lastConfirmedDate!;
        final confirmedDate = DateTime(lastConfirmed.year, lastConfirmed.month, lastConfirmed.day);
        
        // Si la √∫ltima confirmaci√≥n es HOY y la racha > 0, es sospechoso
        if (confirmedDate.isAtSameMomentAs(today) && streak.currentStreak > 0) {
          suspiciousChallenges.add(challengeId);
          debugPrint('üö® Reto sospechoso encontrado: $challengeId - Racha: ${streak.currentStreak} - Fecha: ${streak.lastConfirmedDate}');
        }
      }
    }
    
    // Resetear solo los retos sospechosos
    for (final challengeId in suspiciousChallenges) {
      final currentStreak = _streaks[challengeId]!;
      _streaks[challengeId] = currentStreak.copyWith(
        currentStreak: 0,
        lastConfirmedDate: null,
        // Preservar longestStreak y totalPoints
      );
      debugPrint('‚úÖ Reset quir√∫rgico aplicado a: $challengeId');
    }
    
    // Guardar cambios
    await _saveStreaks();
    notifyListeners();
    debugPrint('üîß QUIR√öRGICO: Correcci√≥n completada. ${suspiciousChallenges.length} retos corregidos.');
  }

  // üîç M√âTODO DE DIAGN√ìSTICO: Mostrar estado detallado de todos los retos
  void diagnosticShowAllStreaks() {
    debugPrint('üîç === DIAGN√ìSTICO: Estado de todos los retos ===');
    
    if (_streaks.isEmpty) {
      debugPrint('üì≠ No hay retos registrados');
      return;
    }
    
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    
    for (final entry in _streaks.entries) {
      final challengeId = entry.key;
      final streak = entry.value;
      
      debugPrint('üéØ Reto: $challengeId (${streak.challengeTitle})');
      debugPrint('   üìä Racha actual: ${streak.currentStreak}');
      debugPrint('   üèÜ Mejor racha: ${streak.longestStreak}');
      debugPrint('   üìÖ √öltima confirmaci√≥n: ${streak.lastConfirmedDate}');
      debugPrint('   üíØ Puntos totales: ${streak.totalPoints}');
      
      if (streak.lastConfirmedDate != null) {
        final lastConfirmed = streak.lastConfirmedDate!;
        final confirmedDate = DateTime(lastConfirmed.year, lastConfirmed.month, lastConfirmed.day);
        final daysDiff = today.difference(confirmedDate).inDays;
        
        if (confirmedDate.isAtSameMomentAs(today)) {
          debugPrint('   ‚ö†Ô∏è SOSPECHOSO: √öltima confirmaci√≥n es HOY con racha > 0');
        } else if (daysDiff > 0) {
          debugPrint('   üìä D√≠as desde √∫ltima confirmaci√≥n: $daysDiff');
        }
      }
      
      debugPrint('   ---');
    }
    
    debugPrint('üîç === FIN DIAGN√ìSTICO ===');
  }
}
